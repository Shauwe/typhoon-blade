#labels Featured
= Blade是什么 =

软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。
 
很多人还在手工编写 Makefile，又没有去写正确的依赖，导致每次不得不先 make clean 才放心，Make的意义大打折扣。这在几个文件的小项目下是没什么问题的，对于大的项目就很不方便了。

Autotools 号称auto，但是还是需要人工写很多东西，运行一系列命令，用起来还是比较复杂，开发人员的学习和使用的门槛很高。

Blade 就是针对这些问题，为腾讯公司基础架构部的“台风”云计算平台项目而开发的新一代构建工具，希望能成为开发者手中的“瑞士军刀”。我们现在把它开源出来，希望能让更多的人得到方便。

= Blade 解决的问题 =
 * 源文件更新导致需要重新构建。这个 gnu make 都能解决得很好。
 * 头文件更新，所以以来这个头文件的源文件都需要重新构建。这个 gnu make 不直接支持，需要搭配 gcc 来生成和更新依赖。
 * 库文件更新，所依赖的库文件更新后，程序应该重新连接，GNU Make 可以做到。
 * 即使我只构建自己的目标，如果库的源代码变了，库应该重新生成，GNU Make 用递归 Make 无法做到。
 * 库文件之间的依赖自动传递，一个库依赖另一个库，库的最终用户不需要关心。
 * 构建过程中的警告和错误应该醒目地显示出来。
 * 能自动支持台风系统大量使用的 proto buffer，以及方便扩充以支持外来可能引入的新工具。
 * 应该能集成自动测试，代码检查等开发常用的功能。

=Blade运行条件=
Blade 运行时需要以下条件：
 * SCons v2.0 or later   (required)
 * Python v2.6 or later  (required)
 * ccache v3.1 or later  (optional)

Blade 编译项目时可能需要到：
 * swig   v2.0 or later  (required for swig_library)
 * flex v2.5 or later    (required for lex_yacc)
 * bison v2.1 or later   (required for lex_yacc)

=源代码树的组织=
项目都要求源代码有明确的根目录，C++ 中的 #include 的路径也需要从这个目录开始写起，这样能有效地避免头文件重名造成的问题。
Blade并不从某个配置文件或者环境变量读取这个信息，因为开发人员往往需要同时有多个目录树并存。Blade获取源代码根的方法是，无论当前从哪一级子目录运行，都从当前目录开始向上查找BLADE_ROOT文件，有这个文件的目录即为源代码树的根。

目前源代码目录需要自己拉取，将来我们会集成到 Blade 中。BLADE_ROOT 文件也需要用户自己创建。方法：
 $ touch BLADE_ROOT

一个源代码树的根目录看起来的样子如下：
 BLADE_ROOT
 common
 thirdparty
 xfs
 xcube
 torca
 your_project
 ...

= BUILD文件 =

Blade 通过一系列的名字为 "BUILD" 的文件（文件名全大写），这些文件需要开发者去编写。每个 BUILD文件通过一组目标描述函数描述了一个目标的源文件，所依赖的其他目标，以及其他一些属性。

== BUILD文件的示例 ==

构建脚本很简单：

范例：common/base/string/BUILD
{{{
cc_library(
    name = 'string',
    srcs = [
        'algorithm.cpp',
        'string_number.cpp',
        'string_piece.cpp',
        'format.cpp',
        'concat.cpp'
    ],
    deps = ['//common/base:int']
)
}}}
也是说明式的，只需要列出目标名，源文件名和依赖名（可以没有）即可。

==风格建议==
 * 四空格缩进，不要用tab字符
 * 总是用单引号
 * 目标名用小写
 * src 里的文件名按字母顺序排列
 * deps 里先写本目录内的依赖（:target），后写其他目录内的（//dir:name），分别按字母顺序排列。
 * 不同目标之间空一行，前面可以加注释
 * 注释的 # 后面空一格，比如 # This is a comment

==描述目标==

Blade用一组target函数来定义目标，这些target的通用属性有：
 * name: 字符串，和路径一起成为target的唯一标识，也决定了构建的输出命名
 * srcs: 列表或字符串，构建该对象需要的源文件，一般在当前目录，或相对于当前目录的子目录中
 * deps: 列表或字符串，该对象所依赖的其它targets

deps的允许的格式：
 * "//path/to/dir/:name" 其他目录下的target，path为从BUILD_ROOT出发的路径，name为被依赖的目标名。看见就知道在哪里。
 * ":name" 当前目录下的target， path可以省略。
 * "#pthread" 系统库。直接写#跟名字即可。

cc_`*` 目标
包括 cc_test, cc_binary, cc_library，CC 目标均支持的参数为：
 * srcs 源文件列表
 * deps 依赖列表
 * incs 头文件路径列表，仅用于thirdparty
 * defs 宏定义列表，仅用于thirdparty
 * warning 警告设置，仅用于thirdparty
 * optimize 优化设置

{| border="1" 
|- 
| 字段 || 解释 || 举例 || 备注
|- 
| [[warning]] || 是否屏蔽warning  || warning='no' || 默认不屏蔽 warning='yes' , 默认不用写，已开启
|- 
| [[defs]] || 用户定义的宏加入编译中 || defs=['_MT'] || 如果用户定义C++关键字，报warning
|- 
| [[incs]] || 用户定义的include || incs=['poppy/myinc'] || 用户通常不要使用 
|- 
| [[optimize]] || 用户定义的optimize flags || optimize=['O3'] || 适用于 cc_library cc_binary cc_test proto_library
swig_library  cc_plugin resource_library
|}

===cc_library===
用于描述C++库目标。
cc_library同时用于构建静态和动态库，默认只构建静态库，只有被dynamic_link=1的cc_binary依赖时或者命令行指定
--generate-dynamic 才生成动态链接库。

举例：
{{{
cc_library(
    name='lowercase',
    srcs=['./src/lower/plowercase.cpp'],  
    deps=['#pthread'],
    link_all_symbols=False
)
}}}
   
 * link_all_symbols=True
库在被静态链接时，确保库里所有的符号都被链接，以保证依赖全局对象构造函数，比如自动注册器的代码能够正常工作。

需要全部链接的部分最好单独拆分出来做成全部链接的库，而不是整个库全都全部链接，否则会无端增大可执行文件的大小。

相当于原来的force_link，不过是在用在生成而不是使用库时。需要注意的是，link_all_symbols是库自身的属性，不是使用库时的属性。

 * always_optimize
True: 不论debug版本还是release版本总是被优化。
False: debug版本不作优化。
默认为False。目前只对cc_library有效。

 * prebuilt=True
主要应用在thirdparty中从rpm包解来的库，使用这个参数表示不从源码构建。对应的二进制文件必须存在 lib{32,64}_{release,debug} 这样的子目录中。不区分debug/release时可以只有两个实际的目录。

在老的 BUILD 文件中你可能看到 pre_build 这个词，这是 prebuilt 的错误拼写，已经修正为现在的名字，并淘汰了旧的名字。

===cc_binary===
定义C++可执行文件目标
{{{
cc_binary(
    name='prstr',
    srcs=['./src/mystr_main/mystring.cpp'],
    deps=['#pthread',':lowercase',':uppercase','#dl'],
)
}}}

 * dynamic_link=True
目前我们的binary默认为全静态编译以适应云计算平台使用。
如果有应用需要动态编译方式，可以使用此参数指定，此时被此target依赖的所有库都会自动生成对应的动态库供链接。
需要注意的是，dynamic_link只适用于可执行文件，不适用于库。

 * export_dynamic=True
Pass the flag ‘-export-dynamic’ to the ELF linker, on targets that support
it. This instructs the linker to add all symbols, not only used ones, to the
dynamic symbol table. This option is needed for some uses of dlopen or to
allow obtaining backtraces from within a program.

===cc_test===
相当于cc_binary，再加上自动链接gtest和gtest_main
还支持testdata参数， 列表或字符串，文件会被链接到输出所在目录name.runfiles子目录下，比如：testdata/a.txt =>name.runfiles/testdata/a.txt
用blade -runtests(简写-t)命令，会在成功构建后到name.runfiles目录下自动运行，并输出总结信息。

 * testdata=[]
在name.runfiles里建立symbolic link指向工程目录的文件，目前支持
以下几种形式
 * 'file'
在测试程序中使用这个名字本身的形式来访问
 * '//your_proj/path/file'
在测试程序中用"your_proj/path/file"来访问。
 * ('//your_proj/path/file', "new_name")
在测试程序中用"new_name"来访问

可以根据需要自行选择，这些路径都也可以是目录。
{{{
cc_test(
    name = 'textfile_test',
    srcs = 'textfile_test.cpp',
    deps = ':io',
    testdata = [
        'test_dos.txt',
        '//your_proj/path/file',
        ('//your_proj/path/file', 'new_name')
    ]
)
}}}

 * export_dynamic=True
Pass the flag ‘-export-dynamic’ to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of dlopen or to allow obtaining backtraces from within a program.

=== proto_library ===
用于定义protobuf目标
deps 为import所涉及的其他proto_library 
自动依赖protobuf，使用者不需要再显式指定。
构建时自动调用protoc生成cc和h，并且编译成对应的cc_library
{{{
proto_library(
    name = 'rpc_meta_info_proto',
    srcs = 'rpc_meta_info.proto',
    deps = ':rpc_option_proto',
)
}}}
Blade支持proto_library，使得在项目中使用protobuf十分方便。

要引用某 proto 文件生成的头文件，需要从 BLADE_ROOT 的目录开始，只是把 proto 扩展名改为 pb.h 扩展名。
比如 //common/base/string_test.proto 生成的头文件，路径为 "common/base/string_test.pb.h"。

===lex_yacc_library===
srcs 必须为二元列表，后缀分别为ll和yy
构建时自动调用flex和bison, 并且编译成对应的cc_library
{{{
lex_yacc_library(
     name = 'parser',
     srcs = [
         'line_parser.ll', 
         'line_parser.yy'
     ],
     deps = [
         ":xcubetools",
     ],
     recursive=1
)
}}}

* recursive=True
生成可重入的C scanner.
flex has the ability to generate a reentrant C scanner. This is accomplished by specifying %option reentrant (`-R').
例如：

可以同时扫描两个文件并且在token level比较而不是单个字符比较
{{{
/* Example of maintaining more than one active scanner. */
     
do {
    int tok1, tok2;
     
    tok1 = yylex( scanner_1 );
    tok2 = yylex( scanner_2 );
     
    if( tok1 != tok2 )
        printf("Files are different.");
     
} while ( tok1 && tok2 );
}}}

===gen_rule===
用于定制自己的目标
outs = []，表示输出的文件列表，需要填写这个域gen_rule才会被执行
cmd, 字符串，表示被调用的命令行
cmd中可含有如下变量，运行时会被替换成srcs和outs中的对应值
$SRCS
$OUTS
$FIRST_SRC
$FIRST_OUT
$BUILD_DIR -- 可被替换为 build[64,32]_[release,debug] 输出目录
{{{
gen_rule(
    name='test_gen_target',
    cmd='echo what_a_nice_day;touch test2.c',
    deps=[':test_gen'],                         # 可以有deps , 也可以被别的target依赖
    outs=['test2.c']
)
}}}
很多用户使用gen_rule动态生成代码文件然后和某个cc_library或者cc_binary一起编译，
需要注意应该尽量在输出目录生成代码文件,如build64_debug下，并且文件的路径名要写对，
如 outs = ['websearch2/project_example/module_1/file_2.cc'], 这样使用
gen_rule生成的文件和库一起编译时就不会发生找不到动态生成的代码文件问题了。

===swig_library===
根据.i文件生成相应的python, java 和php cxx模块代码，并且生成对应语言的代码。
{{{
swig_library(
    name = 'poppy_client',
    srcs = [
        'poppy_client.i'
    ],
    deps = [
        ':poppy_swig_wrap'
    ],
    warning='yes',
    java_package='com.soso.poppy.swig',   # 生成的java文件的所在package名称
    java_lib_packed=1, # 表示把生成的libpoppy_client_java.so打包到依赖者的jar包里，如java_jar依赖这个swig_library
    optimize=['O3']    # 编译优化选项
)
}}}
 * warning
这里的warning仅仅指swig编译参数cpperraswarn是否被指定了，swig_library默认使用非标准编译告警级别（没有那么严格）。

===cc_plugin===
支持生成target所依赖的库都是静态库.a的so库，即plugin。
{{{
cc_plugin(
    name='mystring',
    srcs=['./src/mystr/mystring.cpp'],
    deps=['#pthread',':lowercase',':uppercase','#dl'],
    warning='no',
    defs=['_MT'],
    optimize=['O3']
)
}}}
cc_plugin 是为 JNI，python 扩展等需要动态库的场合设计的，不应该用于其他目的。

===resource_library===
编译静态资源。

大家都遇到过部署一个可执行程序，还要附带一堆辅助文件才能运行起来的情况吧？
blade通过resource_library，支持把程序运行所需要的数据文件也打包到可执行文件里，
比如poppy下的BUILD文件里用的静态资源：
{{{
resource_library(
    name = 'static_resource',
    srcs = [
        'static/favicon.ico',
        'static/forms.html',
        'static/forms.js',
        'static/jquery-1.4.2.min.js',
        'static/jquery.json-2.2.min.js',
        'static/methods.html',
        'static/poppy.html'
    ]
)
}}}
生成  和 libstatic_resource.a 或者 libstatic_resource.so。
就像一样protobuf那样，编译后后生成一个库libstatic_resource.a，和一个相应的头文件static_resource.h，带路径包含进来即可使用。

在程序中需要包含static_resource.h（带上相对于BLADE_ROOT的路径）和"common/base/static_resource.hpp"，
用 STATIC_RESOURCE 宏来引用数据：
{{{
StringPiece data = STATIC_RESOURCE(poppy_static_favicon_ico);
}}}
STATIC_RESOURCE 的参数是从BLADE_ROOT目录开始的数据文件的文件名，把所有非字母数字和下划线的字符都替换为_。

得到的 data 在程序运行期间一直存在，只可读取，不可写入。

用 static resource 在某些情况下也有一点不方便：就是不能在运行期间更新，因此是否使用，需要根据具体场景自己权衡。

===java_jar===
编译java源代码。
{{{
java_jar(
    name = 'poppy_java_client',
    srcs = [
        'src/com/soso/poppy'                 # 这里只需要指定java文件所在目录，不要写上具体java文件列表
    ],
    deps = [
        '//poppy:rpc_meta_info_proto',       # 可以依赖proto_library生成的java文件一起编译打包
        '//poppy:rpc_option_proto',
        '//poppy:rpc_message_proto',
        '//poppy:poppy_client',              # 可以依赖swig_library生成的java文件一起编译打包
        './lib:protobuf-java',               # 可以依赖别的jar包
        './lib:junit',
    ]
)
}}}
 * prebuilt=True
主要应用在已经编译打包好的java jar 包。

=Blade的输出=

构建过程是彩色高亮的
出错信息是彩色的，方便定位错误。

默认生成 native arch 的可执行文件，指定生成 32/64 位结果也很简单，加上 -m32/64即可。
默认生成 release 版本的结果，如果生成 debug 版的，加上 -p debug 即可。
默认构建当前目录，如果当前目录依赖的外面的模块需要重新构建，也会被连带构建起来（Make很难做到）。如果要从当前目录构建所有子目录的目标，也很简单：blade ... 即可。

不同构建选项的结果放在不同的目录下，生成的文件一律按层次也放在这个目录里，不会污染源代码目录。

要清除构建结果（一般不需要），blade clean 即可。

=Blade Cache=
blade 支持 cache，可以大幅度加快构建速度。
blade 支持两种cache
 * ccache , cache配置使用ccache的配置, 如通过配置 CCACHE_DIR 环境变量指定ccache目录。
 * ccache 没有安装，则使用scons cache, 配置细节如下

scons cache需要一个目录，依次按以下顺序检测：
 * 命令行参数--cache-dir
 * 环境变量BLADE_CACHE_DIR
 * 如果均未配置，则不启用cache。
 * 空的BLADE_CACHE_DIR变量或者不带参数值的--cache-dir=, 则会禁止cache。

--cache-size 如不指定，则默认为2G，如指定，则使用用户指定的以Gigabyte为单位的大小的cache。
如 --cache-dir='~/user_cache' --cache-size=16 (16 G)大小cache。
用户可以根据需要配置大小，超出大小blade会执行清理工作，限制cache大小在用户指定的cache大小，
请谨慎设置这个大小，因为涉及到构建速度和机器磁盘空间的占用。

= 测试支持 =
Blade test支持增量测试 ，可以加快tests的执行。
已经Pass 的tests 在下一次构建和测试时不需要再跑，除非：
 * tests 的任何依赖变化导致其重新生成。
 * tests 依赖的测试数据改变，这种依赖为显式依赖，用户需要使用BUILD文件指定，如testdata。
 * tests 所在环境变量发生改变。
 * test arguments 改变。
 * Fail 的test cases ，每次都重跑。
如果需要使用全量测试，使用--full-test option, 如 blade test common/... --full-test ， 全部测试都需要跑。
另外，cc_test 支持了 always_run 属性，用于在增量测试时，不管上次的执行结果，每次总是要跑。
{{{
cc_test(
    name = 'zookeeper_test',
    srcs = 'zookeeper_test.cc',
    always_run = True
)
}}}

Blade test支持并行测试，并行测试把这一次构建后需要跑的test cases并发地run。
blade test [targets] --test-jobs N
-t, --test-jobs N 设置并发测试的并发数，Blade会让N个测试进程并行执行
 
对于某些因为可能相互干扰而不能并行跑的测试，可以加上 exclusive 属性
{{{
cc_test(
    name = 'zookeeper_test',
    srcs = 'zookeeper_test.cc',
    exclusive = True
)
}}}

=命令行参考=

blade `[`action`]` `[`options`]` `[`targets`]`

action是一个动作，目前有
 * build 表示构建项目
 * test  表示构建并且跑单元测试
 * clean 表示清除目标的构建结果
 * query 查询目标的依赖项与被依赖项
 * run   构建并run一个单一目标

targets是一个列表，支持的格式：
 * path:name 表示path中的某个target
 * path表示path中所有targets
 * path/... 表示path中所有targets，并递归包括所有子目录
 * :name表示当前目录下的某个target
默认表示当前目录

参数列表：
 * -m32,-m64            指定构建目标位数，默认为自动检测
 * -p PROFILE           指定debug/release，默认release
 * -k, --keep-going     构建过程中遇到错误继续执行（如果是致命错误不能继续）
 * -j N,--jobs=N        N路并行编译，多CPU机器上适用
 * -t N,--test-jobs=N   N路并行测试，多CPU机器上适用
 * --cache-dir=DIR      指定一个cache目录
 * --cache-size=SZ      指定cache大小，以G为单位
 * --verbose            完整输出所运行的每条命令行
 * –h, --help           显示帮助
 * --color=yes/no/auto  是否开启彩色
 * --generate-dynamic   强制生成动态库
 * --generate-java      为proto_library 和 swig_library 生成java文件
 * --generate-php       为proto_library 和 swig_library 生成php文件
 * --gprof              支持 GNU gprof
 * --gcov               支持 GNU gcov 做覆盖率测试

= 环境变量 =

Blade支持以下环境变量：
 * TOOLCHAIN_DIR，默认为空
 * CPP，默认为cpp
 * CXX，默认为c++
 * CC，默认为gcc
 * LD，默认为c++
 
TOOLCHAIN_DIR和CPP等组合起来，构成调用工具的完整路径，例如：
 
调用/usr/bin下的gcc（开发机上的原版gcc）
 TOOLCHAIN_DIR=/usr/bin blade

使用clang
 CPP='clang -E' CC=clang CXX=clang++ ld=clang++ blade

如同所有的环境变量设置规则，放在命令行前的环境变量，只对这一次调用起作用，如果要后续起作用，用 export，要持久生效，放入 ~/.profile 中。

环境变量的支持将来考虑淘汰，改为配置编译器版本的方式，因此建议暂时不要使用。

= 辅助命令 =

== install ==
blade命令的符号链接会被安装下面的命令到~/bin 下。

== lsrc ==
列出当前目录下指定的源文件，以blade的srcs列表格式输出。

== genlibbuild ==
自动生成以目录名为库名的cc_library，以测试文件的名为名的cc_test，proto的BUILD文件，并假设这些测试都依赖这个库

== vim集成 ==
我们编写了vim的blade语法文件，高亮显示blade关键字，install后就会自动生效。

我们编写了 Blade 命令，使得可以在 vim 中直接执行 blade，并快速跳转到出错行（得益于 vim 的 [http://easwy.com/blog/archives/advanced-vim-skills-quickfix-mode/ quickfix] 特性）。

{{{
function! Blade(...)
    let l:old_makeprg = &makeprg
    setlocal makeprg=blade
    execute "make " . join(a:000)
    let &makeprg=old_makeprg
endfunction

command! -complete=dir -nargs=* Blade call Blade('<args>')
}}}

使用时直接在 vim 的 : 模式输入（可带参数）
:Blade
即可构建。

这个命令的源代码在 common/tools/.vimrc 中。

==alt==
在源代码目录和构建目标目录之间跳转

=安装=

执行install脚本即可安装到~/bin下，目前因还在开发阶段，变化还比较快，以软链方式安装，install后不能删除checkout出来的原始目录。
目前blade生成scons脚本，因此还需要安装scons 2.0以上版本。
Blade 需要至少 Python 2.6，我们建议使用 python 2.7.x (x越高越好)，但不用 python3

install使得可以在任何目录下直接执行
 $ blade
命令。
如果不行，确保~/bin在你的PATH环境变量里，否则修改 ~/.profile，加入
 export PATH=~/bin:$PATH
重新登录即可。


我们的理念：解放程序员，提高生产力。用工具来解决非创造性的技术问题。

= Blade FAQ =

== 运行环境 ==

=== 为什么blade不能在我的平台运行？===

描述： 
运行blade , 报syntax error。

解决过程：
 # blade 运行需要python 2.6 或者以上(2.7). 请使用python -V 查看python 版本。
 # 另外CI曾经遇到这样一个问题装了python 2.7还是报错，经查看是存在两个python版本2.4 和 2.7，很多系统都存在两个版本，请检查高版本python在blade用户的profile中。
 # 使用env python, which python 等命令查看。

结论：
 * 环境配置问题。

=== vim 编辑 BUILD 文件时没有语法高亮 ===
 * 首先确认是否是以 install 的方式安装的
 * 然后检查 ~/.vim/syntax/blade.vim 是否存在，是否指向正确的文件
 * 然后检查 ~/.vimrc 里是否有 autocmd! BufRead,BufNewFile BUILD set filetype=blade
这条命令。
 * 如果问题还没解决，请联系我们。

=== 为什么alt用不了？===

描述：
alt 用不了

解决过程：
 # 重新执行install
 # 把 ~/bin 加入到用户profile


结论：
* PATH 问题。


== 构建问题 ==

=== 为什么deps 里有写的依赖target顺序不同，编译结果不同？===

描述：
//common/config/ini:ini 在某个库的deps里放置的顺序不同，放前面没有通过，放到后面通过了。

解决过程：
 * 查看编译错误输出，中间有个库su.1.0是prebuilt库。
 * //common/config/ini:ini 放在这个target 前后编译结果不一样。
 * 经查看，su.1.0 依赖//common/config/ini:ini，但是没有编译进静态库。所以
//common/config/ini:ini 放到它后面时，gcc按顺序查找能查找到symbols, 但放在
su.1.0 前就查找不到了，所以输出undefined reference.

结论：
 * 建议尽量源代码编译项目。
 * 减少prebuilt项目，prebuilt库尽量补全依赖的target。

=== ccache缓存了错误信息，是不是ccache出问题了？===
 
描述：
编译提示有错误，在源文件里修改后重新编译还是有错误，是不是ccache缓存了告警或者错误信息，没有更新出问题了 ？

解决过程：
 # 查看ccache manual, ccache在direct mode 可能会有internal error。
 # 告知XFS同事如果再次遇到这个问题，立刻修改配置查看是否是cache自身问题。
 # 同时查看预处理cpp文件后的结果，发现头文件修改没有反映在预处理后的文件里。
 # 应该是包含路径错误，经过查找，build64_release下存在相同的头文件，而且build64_release默认是加到
-I里， 编译时默认加入 -Ibuild64_realease -I. 
在build64_realease 首先查找头文件， 因此找到这个同名头文件，XFS同事放了一个文件在这个输出目录里，但是修改的却是
自己的工程文件。


结论：
 * 检查include path。

=== 为什么不要从windows里拉下svn代码再放在linux开发机编译？===
因为代码库里有些文件是符号链接，Windows 上的 SVN 客户端不支持符号链接。
windows 上 checkout 出来的代码，放到 linux 下，符号链接不正确，blade编译不了。

=== 我只有一个没有源代码的库，如何使用 ===
请参考[[#cc_library]]中，关于prebuilt的部分。

=== prebuilt 库只有.so文件，我也只需要编译.so 库？===
描述：
prebuilt 库只有.so文件，我也只需要编译.so 库

解决过程：
 # cc_library 如果需要编译为动态库，那么只需要提供动态库。
 # cc_plugin 需要静态库。

结论：
 * 所以prebuilt库最好提供静态库和动态库。
 * 升级到最新blade。

=== 别的组只提供了静态库，但是我们需要编译动态库 ===
描述：
别的组只提供了静态库，但是我们需要编译动态库 ？

解决过程：
 # .a files are just archives of .o object files, so all you need to do is unpack the archive and repackage them as a shared object (.so)。

ar -x mylib.a
gcc -shared *.o -o mylib.so

 # common 组有脚本自动转, common/tools/atoso
 # so 不能转为 .a 库。

结论：要求相关组提供好.a， .so prebuilt 库。

=== blade支持环境变量里指定的gcc去编译项目吗？===
描述：
想使用特定版本的gcc编译项目。

解决过程：
 * CC=/usr/bin/gcc CXX=/usr/bin/g++ CPP=/usr/bin/cpp LD=/usr/bin/g++ blade targets 

结论：
 * 升级到最新blade且注意环境变量的配置要一致，即使用版本一致的编译器和linker。

=== 我的代码已经修改了，blade编译还有问题？===
描述：
在CI机器上，blade编译有error, 修复错误后从新从svn拉取，但是还是提示相同的错误。

解决过程：
 * 检查文件是否是修改后的copy.
 * 该文件由于在CI机器上是root权限，而该同事登录机器的用户名不是root, 覆盖不了原来的文件。
 * 提示错误的文件是老文件。

结论：
 * 权限切换时需要注意文件的所属者。

=== 编译出来的SO库带有路径信息？===
描述：
使用Blade编译出来的so库带有路径信息，使用起来麻烦，可以配置更改一下吗 ？

在一个大的项目中，不同的子项目，库完全可能重名，如果人工去协调这个问题，显然是划不来的。
因此，Blade使用库时，总是带有路径信息的，从根本上避免了这个问题。用的时候也带上路径即可。

=== 为什么Blade新加的error flag 不起作用？===
描述：
使用更新后的Blade编译本地项目发现error flag 没有起作用 ？

解决过程：
 # 检查Blade是否是最新的。
 # 检查cpp程序是否把error flag 过滤了，如果不支持这个error flag, Blade 不会使用，否则编译报错。
 # 检查后发现gcc版本过低。

结论：
 * 升级gcc。

=== blade -c 清除不了项目生成的文件 ===
描述：
blade -c 清除不了项目生成的文件

解决过程：
 # 请先检查命令是否配对使用blade -prelease with blade -prelease -c , blade -pdebug with blade -pdebug -c。

结论：
 * 检查命令。

=== 如何显示构建的命令行 ===
我想看到构建过程中中执行的完整命令。
构建时加上 --verbose 参数，就能显示完整的命令行。

=== 我修改了源文件，为何还是失败，报错位置也匹配不上(或者没有重新编译)? ===
首先 alt 到 build 目录下，看看是不是把源代码（或者头文件）放在这里了，由于 Blade 分离了源码和构建结果目录，Blade 也会到构建结果目录找源码优先，而且由于 scons 的限制，还会更优先，因此产生这样的错误，目前还没有好的解决办法。
如果是源文件误放到这里，构建时会显示 Compiling build64_release/...，根据这一点能更容易定位这个问题。

=== 如何发布预编译的库? ===
有些机密的代码，希望以库的方式发布，但同时又依赖了非机密的库（比如common），如何发布呢？
比如这样的库：
{{{
cc_library(
    name = 'secrity',
    srcs = 'secrity.cpp',
    deps = [
        '//common/base/string:string',
        '//thirdparty/glog:glog',
    ]
)
}}}
这样发布：
修改 BUILD 文件，去掉 srcs
{{{
cc_library(
    name = 'secrity',
    prebuilt = True, # srcs 改为这个
    deps = [
        '//common/base/string:string',
        '//thirdparty/glog:glog',
    ]
)
}}}
同时对外的头文件保持不变，按照cc_library介绍中，prebuild要求的方式组织库即可。
尤其需要注意的是，deps 必须保持不变，且不要把虽然被你一来但却不属于你的项目的库作为预编译库发布出去。

=== unrecognized options 是什么意思？===
比如 unrecognized options {'link_all_symbols': 1}。
不同的目标有不同的选项参数，如果传了目标所不支持的参数，就会报告这个错误。可能的原因是误用了其他目标的参数，或者拼写错误，对于后一种情况，BLADE的vim语法高亮功能可以帮你更容易看到错误。

=== Source file xxx.cc belongs to both xxx and yyy 是什么意思？ ===
比如 Source file cp_test_config.cc belongs to both cc_test xcube/cp/jobcontrol:job_controller_test and cc_test xcube/cp/jobcontrol:job_context_test？

为了避免不必要的重复编译和可能的编译参数不同导致违反 C++ 的[http://en.wikipedia.org/wiki/One_Definition_Rule 一次定义规则]，通常每个源文件应该只属于一个目标，如果一个源文件被多个目标使用，应该写成单独的 cc_library，并在 deps 中依赖这个库。

== 程序故障 ==

=== 程序无法一次读取超过2G的文件，是不是Blade的问题？===

描述： 
以前用makefile编译的SU程序一次read调用能读到超过2G大小文件内容，用blade不可以了，是不是blade
链接了错误的GLIBC库。

内核限制了read一次读出数据大小，实验时读出数据大小也小于2G，单独用gcc测试也无法一次全部读取2G以上的文件，因此Blade没有问题，
先前能读取可能是做了什么特殊处理。

=== fbox 用blade编译后core ？===

描述：
fbox 用blade编译后运行core, 查看log, 发现不能查找到某个symbol。

解决过程：
 # 检查BUILD 文件link all symbols， dynamic_link flags 是否用错target
 # 检查后发现有错，重新写好后，再次编译运行，还是找不到某个symbol
 # 某个symbol没有扩展到exe里的动态符号表里，某个库需要使用这个symbol, 但是查找不到，所以core,
动态库引用主程序中的符号，运行时找不到这个符号。链接时需要使用-rdynamic链接选项。
cc_binary里使用export_dynamic=1  传送‘-export-dynamic’ 给 ELF linker。

结论：
如果在exe里想使用dlopen打开一个动态库，而动态库想使用exe里的某些符号，请使用export_dynamic选项。

=== 运维机器的gcc版本不同，编译的agent 不能部署到所有机器 ===

描述：
机器的gcc版本不同，编译的agent不能作统一部署。

解决过程：
 * libgcc 没有加入到cc_binary 静态链接。
 * 立刻支持静态链接GLIBC特定版本。

结论：
 * 升级到新版本blade解决。

=== 加上-finstrument-functions后程序core了 ===

描述：
需要在编译时加上 -finstrument-functions 查看函数调用关系，
加在extra_cppflags 里，但是编译后运行程序core了

解决过程：
 * blade使用g++编译程序。
 * 发现没有自定义void __cyg_profile_func_enter (void *, void *)  和 void __cyg_profile_func_exit (void *, void *)。
 * 自己定义以上两个函数并且用extern "C"声明。

结论：
 * 用户定义void __cyg_profile_func_enter (void *, void *)  和 void __cyg_profile_func_exit (void *, void *)。

=== 需要用到一个prebuild库，用Blade编译后程序hang了，是不是blade编译问题 ===

描述：
需要使用到一个c库，先用这个库提供的Makefile编译生成prebuild的库。
然后程序里使用这个prebuild库, 但是一旦使用到相关代码，程序运行时就hang住，
不能进入main函数继续执行。

解决过程：
 # gdb debug 发现tcmalloc用到的一个初始化函数InitModule使用了两次，造成spinlock被递归持有，造成死锁。
 # 查找为什么会被调用两次，发现c标准库里的一个函数符号被这个prebuild库的一个函数符号覆盖。
 # 覆盖后的函数有调用malloc行为，但是tcmalloc还没有被初始化完，所有又初始化一次，造成锁被递归持有，
从而陷入等待状态。

结论：
 * 用户把这个prebuild库改为使用blade源代码编译方式。